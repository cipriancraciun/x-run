<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>z-run(1) - lightweight scripts library tool</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#SYNOPSIS">SYNOPSIS</a>
    <a href="#ARGUMENTS">ARGUMENTS</a>
    <a href="#COMMANDS">COMMANDS</a>
    <a href="#FLAGS">FLAGS</a>
    <a href="#ENVIRONMENT">ENVIRONMENT</a>
    <a href="#LIBRARY">LIBRARY</a>
    <a href="#NOTES">NOTES</a>
    <a href="#EXAMPLES">EXAMPLES</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>z-run(1)</li>
    <li class='tc'></li>
    <li class='tr'>z-run(1)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>z-run</code> - <span class="man-whatis">lightweight scripts library tool</span>
</p>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p><code>z-run</code> is a lightweight and portable tool that allows one to create and execute a library of scripts.</p>

<p>A "script", or "scriptlet" how it's named in the case of <code>z-run</code>,
is nothing more than an usual Bash, Python, Ruby, NodeJS, or any other interpreted language, script.
Basically one can just take the contents of a normal script file, and use it as the body of a scriptlet.</p>

<p>A "library" is just a collection of many such "scriptlets" that are bundled together in (usually) one,
or (sometimes for more complex scenarios) multiple, files.</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<h3 id="Basic-modes">Basic modes</h3>

<p><code>z-run</code> <br />
<code>z-run</code> <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ] <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>&lt;command></code> [ <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ] ]
<code>z-run</code> <code>--version</code></p>

<h3 id="Advanced-modes">Advanced modes</h3>

<p><code>z-run</code> <code>--exec</code> <code>&lt;library></code> [ <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ] ] <br />
<code>z-run</code> <code>--ssh</code> [ <code>&lt;flag></code> ... ] <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ] <br />
<code>z-run</code> <code>--invoke</code> <code>&lt;invoke-payload></code> <br /></p>

<h3 id="Input-mode">Input mode</h3>

<p><code>z-run</code> <code>--select</code> <br />
<code>z-run</code> <code>--input</code> [ <code>--message=&lt;message></code> ] [ <code>--prompt=&lt;prompt></code> ] [ <code>--sensitive</code> ] <br />
<code>z-run</code> <code>--fzf</code> [ ... ] <br /></p>

<h2 id="ARGUMENTS">ARGUMENTS</h2>

<p><code>&lt;command></code></p>

<p>  the name of a built-in <code>z-run</code> command;
  it is always a word (made of letters or digits), or multiple words joined by hyphen (<code>'-'</code>);
  (see bellow for details;)</p>

<p><code>&lt;scriptlet></code></p>

<p>  the label of the scriptlet within the library;
  it always starts with two colons <code>'::'</code>, then optionally followed by spaces, while the rest should match the label of an existing scriptlet;
  they never contain control characters (e.g. <code>'\0'</code>, <code>'\t'</code>, <code>'\n'</code>, etc.), but they might contain any other UTF-8 characters;
  (obviously shell quoting or escaping is required if spaces are used;)
  (e.g. <code>':: scriptlet'</code>;)</p>

<p><code>&lt;argument></code></p>

<p>  in case of commands that execute the scriptlet, the arguments passed to the scriptlet, they are never inspected or interpreted by <code>z-run</code>;
  in case of other commands, they might have a different meaning;
  (regardless the case, any <code>z-run</code> flag should come before the scriptlet;)</p>

<p><code>&lt;flag></code></p>

<p>  the name of a built-in <code>z-run</code> flag;
  it always starts with <code>--</code> and is followed by a word (made of letters or digits), or multiple words joined by a hyphen;
  if it takes a value it should be immediately followed by an <code>=</code> and the given value;
  (i.e. flag values are part of the flag argument, like <code>--flag=value</code>, and not like <code>--flag value</code>;)
  any flags must appear before the <code>&lt;command></code> and <code>&lt;scriptlet></code>;</p>

<p><code>&lt;rpc-target></code></p>

<p>  a TCP or UNIX domain socket that will be used to export or use the library over the <code>z-run</code> specific RPC;
  it is either <code>tcp:&lt;ip-address>:&lt;port></code>, <code>tcp:&lt;dns>:&lt;port></code>, <code>unix:&lt;path></code>, or <code>unix:@&lt;token></code>;
  (the last form is only supported on Linux, and represents an abstract UNIX domain socket;)</p>

<p><code>&lt;ssh-target></code></p>

<p>  usually <code>user@machine</code> or just <code>machine</code> that identifies the SSH target;</p>

<p><code>&lt;argument-0></code></p>

<p>  (i.e. the first argument in <code>main (argv)</code>)
  must always be the actual executable path (either absolute or relative), or alternatively <code>z-run</code> (or a few other aliases);
  other values are internally used by <code>z-run</code> itself;</p>

<h2 id="COMMANDS">COMMANDS</h2>

<h3 id="Scriptlet-execution-commands">Scriptlet execution commands</h3>

<p><code>execute-scriptlet</code>, <code>execute</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>execute-scriptlet</code> <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ]</p>

<p>  expects a mandatory <code>&lt;scriptlet></code>, plus optional scriptlet <code>&lt;arguments></code>;
  executes the specified scriptlet, on the local machine;
  passes any specified arguments to the scriptlet;</p>

<p><code>execute-scriptlet-ssh</code>, <code>execute-ssh</code>, <code>ssh</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>execute-scriptlet-ssh</code> <code>&lt;ssh-target></code> <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ]</p>

<p>  expects a <code>&lt;ssh-target></code>, a mandatory <code>&lt;scriptlet></code>, plus optional scriptlet <code>&lt;arguments></code>;
  executes the specified scriptlet, on the remote machine designated by the SSH target (usually <code>user@machine</code>);
  passes any specified arguments to the scriptlet;</p>

<p><code>select-execute-scriptlet</code>, <code>select-execute</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-execute-scriptlet</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-execute-scriptlet</code> <code>&lt;scriptlet></code></p>

<p>  expects an optional <code>&lt;scriptlet></code>, but no other arguments;
  if no scriptlet is specified, it presents a menu of all the scriptlets in the library, and allows the user to choose one;
  executes the scriptlet (either specified or selected), on the local machine;
  no arguments are passed to the scriptlet;
  usually if scriptlet is specified, it is a sub-menu that is presented instead of the entire library;</p>

<p><code>select-execute-scriptlet-loop</code>, <code>select-execute-loop</code>, <code>loop</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-execute-scriptlet-loop</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-execute-scriptlet-loop</code> <code>&lt;scriptlet></code></p>

<p>  expects an optional <code>&lt;scriptlet></code>, but no other arguments;
  similar to the <code>select-execute-scriptlet</code> command, but it will execute in a loop, presenting a menu, executing the scriptlet, pausing after the execution, and looping until the user exits the main menu;</p>

<h3 id="Scriptlet-related-commands">Scriptlet related commands</h3>

<p><code>export-scriptlet-labels</code>, <code>export-labels</code>, <code>list</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-scriptlet-labels</code></p>

<p>  expects no arguments or scriptlet;
  writes to <code>/dev/stdout</code> the labels of all the scriptlets in the library, one item per line, without the <code>'::'</code> prefix;
  (as mentioned bellow, scriptlet labels can't contain control characters, including <code>'\n'</code>;)</p>

<p><code>export-scriptlet-body</code>, <code>export-body</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-scriptlet-body</code> <code>&lt;scriptlet></code></p>

<p>  expects a mandatory <code>&lt;scriptlet></code>, but no other arguments;
  writes to <code>/dev/stdout</code> the body of the specified scriptlet;
  (as mentioned bellow, scriptlet bodies should be UTF-8 compliant, but might not be;)</p>

<p><code>select-export-scriptlet-label</code>, <code>select-label</code>, <code>select</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-label</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-label</code> <code>&lt;scriptlet></code></p>

<p>  expects an optional <code>&lt;scriptlet></code>, but no other arguments;
  similar to the <code>select-execute-scriptlet</code> command, but it will write to <code>/dev/stdout</code> the label of the specified scriptlet, without the <code>'::'</code> prefix, followed by <code>'\n</code>';</p>

<p><code>select-export-scriptlet-body</code>, <code>select-body</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-body</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-body</code> <code>&lt;scriptlet></code></p>

<p>  expects an optional <code>&lt;scriptlet></code>, but no other arguments;
  similar to the <code>select-execute-scriptlet</code> command, but it will write to <code>/dev/stdout</code> the body of the specified scriptlet, followed by <code>'\n'</code>;</p>

<p><code>select-export-scriptlet-label-and-body</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-label-and-body</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>select-export-scriptlet-label-and-body</code> <code>&lt;scriptlet></code></p>

<p>  expects an optional <code>&lt;scriptlet></code>, but no other arguments;
  similar to the <code>select-execute-scriptlet</code> command, but it will write to <code>/dev/stdout</code> the label of the specified scriptlet, with the <code>'::'</code> prefix, followed by <code>'\n'</code>, and then followed by the body of the specified scriptlet, followed by <code>'\n'</code>;</p>

<h3 id="Library-related-commands">Library related commands</h3>

<p><code>export-library-json</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-library-json</code></p>

<p>  expects no arguments;
  writes to <code>/dev/stdout</code> a series of JSON objects that represents the key-value store that backs the library;
  it uses pretty-printing, thus one JSON object will span over multiple lines;
  the outer serialization format (i.e. <code>namespace</code>, <code>key</code> and <code>value</code>) is unlikely to change in the future;
  the inner serialization format (i.e. <code>namespace</code> values, <code>key</code> and <code>value</code> contents) might change in the future;</p>

<p><code>export-library-cdb</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-library-cdb</code> <code>&lt;cdb-path></code></p>

<p>  expects a single <code>&lt;cdb-path></code>, but no other arguments or scriptlet;
  writes to the specified file path the CDB database that represents the key-value store that backs the library;</p>

<p><code>export-library-rpc</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-library-cdb</code> <code>&lt;rpc-target></code></p>

<p>  expects a single <code>&lt;rpc-target></code>, but no other arguments or scriptlet;
  listens to specified target for <code>z-run</code> specific RPC, that exports the library to remote clients;</p>

<p><code>export-library-url</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-library-url</code></p>

<p>  expects no arguments or scriptlet;
  writes to <code>/dev/stdout</code> a line suitable for using it as value for the <code>--library-cache</code> flag;
  currently it is either a CDB database file <code>&lt;path></code> or <code>&lt;rpc-target></code>;
  <strong>however it should always be treated as an opaque value</strong>, containing any ASCII character, except control characters, as it might change in future versions;</p>

<p><code>export-library-fingerprint</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>export-library-fingerprint</code></p>

<p>  expects no arguments or scriptlet;
  writes to <code>/dev/stdout</code> a line containing the fingerprint of the current library version;
  currently it is an hex-encoded hash;
  <strong>however it should always be treated as an opaque value</strong>, containing any ASCII character, except control characters, as it might change in future versions;</p>

<p><code>parse-library</code> <br />
<code>z-run</code> [ <code>&lt;flag></code> ... ] <code>parse-library</code></p>

<p>  expects no arguments or scriptlet;
  writes to <code>/dev/stdout</code> a single JSON object that represents the internal serialization of the library object;
  it uses pretty-printing, thus the JSON object will span over multiple lines;
  the serialization format is likely to change in the future;</p>

<h3 id="Advanced-modes">Advanced modes</h3>

<p><code>z-run</code> <code>--exec</code> <code>&lt;source-path></code> [ <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ] ]</p>

<p>  expects a library <code>&lt;source-path></code>, an optional <code>&lt;scriptlet></code> and scriptlet <code>&lt;arguments></code>;
  it behaves similarly with the <code>execute-scriptlet</code> command;
  it enables one to write executable <code>z-run</code> scripts by using the <code>#!/usr/bin/env -S z-run --exec</code> header;</p>

<p><code>z-run</code> <code>--ssh</code> [ <code>&lt;ssh-flag></code> | <code>&lt;flag></code> ... ] <code>&lt;scriptlet></code> [ <code>&lt;argument></code> ... ]</p>

<p>  expects a mandatory <code>&lt;scriptlet></code>, plus optional scriptlet <code>&lt;arguments></code>;
  similar to the <code>execute-scriptlet-ssh</code> command, however it allows certain SSH specific arguments as discussed bellow;</p>

<p><code>z-run</code> <code>--invoke</code> <code>&lt;invoke-payload></code></p>

<p>  expects a mandatory <code>&lt;invoke-payload></code> argument, no other flags, arguments or scriptlet;
  the payload contains encoded all the necessary flags, scriptlet and scriptlet arguments;
  it behaves <code>execute-scriptlet</code> command, however it allows one to easily execute <code>z-run</code> over SSH without bothering with <code>ssh</code> and <code>sh</code> command quoting and escaping;
  the serialization format is likely to change in the future;</p>

<h3 id="Input-modes">Input modes</h3>

<p><code>z-run</code> <code>--select</code></p>

<p>  expects no arguments;
  reads from <code>/dev/stdin</code> a list of strings (mandatory compliant with UTF-8), presents a menu to the user, and if anything is selected it writes it to <code>/dev/stdout</code> followed by <code>'\n'</code>;
  it expects (and checks) that both <code>/dev/stdin</code> and <code>/dev/stdout</code> are non-TTY;  (i.e. they must be redirected to a file, pipe, or socket;)
  it expects (and checks) that <code>/dev/stderr</code> is a TTY, and thus requires an usual <code>TERM</code> value;
  it uses an embedded variant of the <code>fzf(1)</code> tool, disregardin any <code>fzf</code> specific flags or environment variables;  (but this should be treated as an implementation detail, and not relied upon;)</p>

<p><code>z-run</code> <code>--input</code> [ <code>--message=&lt;message></code> ] [ <code>--prompt=&lt;prompt></code> ] [ <code>--sensitive</code> ]</p>

<p>  optionally allows any of the flags above;
  writes to <code>/dev/stderr</code> the <code>&lt;message></code> followed by <code>'\n'</code>;
  writes to <code>/dev/stderr</code> the <code>&lt;prompt></code>, or by default <code>'&gt;&gt; '</code>;
  if <code>--sensitive</code> is specified, it disables input echo;
  reads from <code>/dev/stderr</code> a single line (up to the first <code>'\n'</code>), that it then writes to <code>/dev/stdout</code>;
  all values (message, prompt, and input) must be compliant with UTF-8;
  it expects (and checks) that <code>/dev/stdout</code> is non-TTY;  (i.e. it must be redirected to a file, pipe or socket;)
  it expects (and checks) that <code>/dev/stderr</code> is a TTY, and thus requires an usual <code>TERM</code> value;</p>

<p><code>z-run</code> <code>--fzf</code> [ ... ]</p>

<p>  optionally allows any of the flags accepted by <code>fzf(1)</code>;
  similar to <code>--select</code>, however it allows customizing <code>fzf(1)</code> through <code>fzf</code> specific flags and environment variables;
  it expects (and checks) that both <code>/dev/stdin</code> and <code>/dev/stdout</code> are non-TTY;  (i.e. they must be redirected to a file, pipe, or socket;)
  it expects (and checks) that <code>/dev/stderr</code> is a TTY, and thus requires an usual <code>TERM</code> value;</p>

<h3 id="Miscellaneous">Miscellaneous</h3>

<p><code>z-run</code> <code>--version</code></p>

<p>  writes to <code>/dev/stdout</code> a series of lines describing the version, executable, build related, and other miscellaneous information;
  the output format is likely to change in the future;</p>

<h2 id="FLAGS">FLAGS</h2>

<p><code>--untainted</code></p>

<p>  if <code>z-run</code> is invoked within the context of <code>z-run</code> execution, disregard the context, and treat this invocation as a new separate context;
  <strong>must appear as the first flag;</strong>
  (the same applies in <code>--exec</code> mode, which implies <code>--untainted</code>;)</p>

<p><code>--exec</code>, <code>--ssh</code>, and <code>--invoke</code></p>

<p>  these trigger the advanced execution modes described in the sections above;
  <strong>must appear as the first flag;</strong></p>

<p><code>--select</code>, <code>--input</code>, and <code>--fzf</code></p>

<p>  these trigger the input execution modes described in the sections above;
  <strong>must appear as the first flag;</strong></p>

<p><code>--library-source=&lt;source-path></code></p>

<p>  specifies a library <code>&lt;source-path></code>, that overrides the default library source detection mecanism;</p>

<p><code>--library-cache=&lt;cache-url></code></p>

<p>  specifies a library <code>&lt;cache-url></code>, either a <code>&lt;cdb-path></code> or a <code>&lt;rpc-target></code>;
  specifying both <code>--library-source=...</code> and <code>--library-cache=...</code> is not allowed;</p>

<p><code>--workspace=&lt;path></code></p>

<p>  specifies a folder that <code>z-run</code> switches to before executing;
  (if no <code>--library-source=...</code> or <code>--library-cache=...</code> is specified, the default library source detection mecanism uses this folder as the root;)</p>

<p><code>--ssh-target=&lt;ssh-target></code></p>

<p>  <strong>only in SSH mode;</strong>
  specifies the SSH target;</p>

<p><code>--ssh-workspace=&lt;path></code></p>

<p>  <strong>only in SSH mode;</strong>
  specifies a path on the remote machine that <code>z-run</code> switches to before executing;</p>

<p><code>--ssh-export=&lt;name></code></p>

<p>  <strong>only in SSH mode;</strong>
  specifies an environment variable name that is exported on the remote machine;</p>

<p><code>--ssh-path=&lt;path></code></p>

<p>  <strong>only in SSH mode;</strong>
  specifies a value that is appended to the <code>PATH</code> environment variable on the remote machine;</p>

<p><code>--ssh-terminal=&lt;terminal></code></p>

<p>  <strong>only in SSH mode;</strong>
  specifies a value that overrides the <code>TERM</code> environment variable on the remote machine;</p>

<h2 id="ENVIRONMENT">ENVIRONMENT</h2>

<p><code>ZRUN_LIBRARY_SOURCE</code></p>

<p>  an alternative to the <code>--library-source=...</code> flag;
  never exported inside scriptlet execution;</p>

<p><code>ZRUN_LIBRARY_CACHE</code></p>

<p>  an alternative to the <code>--library-cache=...</code> flag;
  always exported inside the scriptlet execution environment;  (never unset it explicitly;)</p>

<p><code>ZRUN_WORKSPACE</code></p>

<p>  an alternative to the <code>--workspace=...</code> flag;
  always exported inside the scriptlet execution environment;  (never unset it explicitly;)</p>

<p><code>ZRUN_EXECUTABLE</code></p>

<p>  always exported inside the scriptlet execution environment;  (never unset it explicitly;)</p>

<p><code>ZRUN_FINGERPRINT</code></p>

<p>  always exported inside the scriptlet execution environment;  (never unset it explicitly;)</p>

<p><code>ZRUN_CACHE</code></p>

<p>  an alternative folder to the default <code>$HOME/.cache/z-run</code>, where various files (and pipes, sockets, etc.) are created;
  (if explicitly specified, it is exported in the scriptlet execution environment;)</p>

<p><code>ZRUN_TERM</code></p>

<p>  an alternative to the default <code>$TERM</code> environment variable;
  (if explicitly specified, it is exported in the scriptlet execution environment;)</p>

<h2 id="LIBRARY">LIBRARY</h2>

<h3 id="Library-source-resolution">Library source resolution</h3>

<p><strong>TBD</strong></p>

<h3 id="Library-source-syntax">Library source syntax</h3>

<p><strong>TBD</strong></p>

<h3 id="Library-directives">Library directives</h3>

<p><strong>TBD</strong></p>

<h3 id="Scriptlet-bodies">Scriptlet bodies</h3>

<p><strong>TBD</strong></p>

<h3 id="Scriptlet-interpreters">Scriptlet interpreters</h3>

<p><strong>TBD</strong></p>

<h2 id="NOTES">NOTES</h2>

<h3 id="Why-z-run-vs-classical-scripts-">Why <code>z-run</code> vs classical scripts?</h3>

<p>What sets <code>z-run</code> aside from a "classical" scripts is:</p>

<ul>
<li><p>first it allows one to easily mix multiple languages;
for example one can easily write a Bash script that chains together a Python, Ruby and another Bash script,
all within the same file;
(with classical scripts one would have had to create multiple files, one for each language, and explicitly invoke them via the interpreter;)</p></li>
<li><p>it allows one to easily bundle together unrelated scripts;
for example say one uses <code>z-run</code> to aid in the development process, then one could bundle together scripts related
to compiling, testing, deploying, and other single-shot shortcuts in the same file;
(again, with classical scripts, one would have usually put each of these in separate files,
or by using <code>case</code> or <code>function</code> try to manage them inside a reduced set of files;)</p></li>
<li><p>it allows one to easily invoke scriptlets from within the same library, without caring what language they are written in, or where their source code is stored;
(with classical scripts one has to take care of getting the paths to other scripts right, especially when running from a different folder than the original one;)</p></li>
</ul>


<p>However <code>z-run</code> takes it a step further by offering the following functionalities:</p>

<ul>
<li><p>environment variables management -- by allowing certain environment variables to be overriden, removed or appended (like in the case of <code>$PATH</code>);
(with classical scripts one has to manage these by themselves, resort to various "envdir" tools, or interact with shell magic;)</p></li>
<li><p>hierarchical menus -- by simply calling <code>z-run</code> without any arguments, it presents one with a selectable menu of all the scriptlets in the library,
and after one selects a scriptlet it executes it;  moreover one can group various scriptlets under other sub-menus, thus allowing arbitrary nesting and navigation;
(when used from a terminal, <code>z-run</code> uses and embedded <code>fzf</code>-based UI;  when used from outside a terminal, <code>z-run</code> tries to use <code>z-run--select</code> (any system), <code>rofi</code> or <code>dmenu</code> (under Linux and BSD's) or <code>choose</code> (under OSX);)</p></li>
<li><p>SSH-based remote execution -- one can easily execute a given scriptlet on a remote server without having to previously copy anything there;
moreover once the scriptlet is executing on the remote server, it can invoke other scriptlets from the library that are also to be executed remotely;
(the only requirement is having <code>z-run</code> installed on the remote machine;)</p></li>
<li><p>scriptlets generation -- one can easily write a scriptlet that generates <code>z-run</code> compliant source, thus generating other scriptlets based on arbitrary criteria;
(for example one could write a scriptlet, that generates other scriptlets specific for each file in a given folder;)</p></li>
<li><p>library compiling -- one can easily create a single file that contains the entire library, which can then be moved and used in another place;</p></li>
<li><p>Go-based templates -- that are useful especially in generating other scriptlets;</p></li>
</ul>


<h3 id="Caching">Caching</h3>

<p><code>z-run</code> is designed to support thousands (and in extreme cases tens of thousands) of scriptlets, especially when scriptlet generation is used.</p>

<p>Therefore <code>z-run</code> has built-in optimizations to cache the library contents (without any regeneration) unless any of the following conditions are met:</p>

<ul>
<li>any of the files that comprise the source code of the library are changed;  (based both on file timestamps and contents hashing;)</li>
<li>any of the environment variables change;</li>
<li>a different version of <code>z-run</code> is installed;  (this covers both upgrading and downgrading;)</li>
</ul>


<p>However once a scriptlet is executed, it and any other invoked scriptlets will use exactly the same cached library contents.
Thus it is safe to change the source code of the library, while a scriptlet is executing.</p>

<h2 id="EXAMPLES">EXAMPLES</h2>

<p><strong>TBD</strong></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>January 2021</li>
    <li class='tr'>z-run(1)</li>
  </ol>

  </div>
</body>
</html>
