#!/dev/null


::// python / test / ...


++<< python / test / all
	# "${ZRUN[@]}" ':: python / test / prolog'
	"${ZRUN[@]}" ':: python / test / prolog / 3'
	"${ZRUN[@]}" ':: python / test / log' 2> /dev/null
	"${ZRUN[@]}" ':: python / test / panic' 2> /dev/null || true
	"${ZRUN[@]}" ':: python / test / zspawn'
	"${ZRUN[@]}" ':: python / test / zexec'
	"${ZRUN[@]}" ':: python / test / spawn'
	"${ZRUN[@]}" ':: python / test / exec'
	"${ZRUN[@]}" ':: python / test / redirects' 2> /dev/null
	"${ZRUN[@]}" ':: python / test / pipeline'
	"${ZRUN[@]}" ':: python / test / wait'
	"${ZRUN[@]}" ':: python / test / communicate'
	"${ZRUN[@]}" ':: python / test / pipes'
	"${ZRUN[@]}" ':: python / test / paths / join'
	"${ZRUN[@]}" ':: python / test / paths / split'
	"${ZRUN[@]}" ':: python / test / stat'
	"${ZRUN[@]}" ':: python / test / touch'
	"${ZRUN[@]}" ':: python / test / environment' > /dev/null
	"${ZRUN[@]}" ':: python / test / sleep'
	"${ZRUN[@]}" ':: python / test / files'
	"${ZRUN[@]}" ':: python / test / random'
!!


<< python / test / prolog
	"${ZRUN[@]}" ':: python / test / prolog / 0'
	"${ZRUN[@]}" ':: python / test / prolog / 2'
	"${ZRUN[@]}" ':: python / test / prolog / 3'
!!

<< python / test / prolog / 0
	#! <python+>
	Z.expect_no_arguments ()
!!

<< python / test / prolog / 2
	#! <python2+>
	Z.expect_no_arguments ()
!!

<< python / test / prolog / 3
	#! <python3+>
	Z.expect_no_arguments ()
!!


<< python / test / log
	#! <python3+>
	Z.expect_no_arguments ()
	Z.log_debug_enabled = True
	Z.log_error (0xd517385b, "this is an error message")
	Z.log_warning (0xb4614c33, "this is a warning message")
	Z.log_notice (0x7049cb1d, "this is a notice message")
	Z.log_debug (0xd8baf265, "this is a debug message")
!!

<< python / test / panic
	#! <python3+>
	Z.expect_no_arguments ()
	Z.panic (0x943040e7, "panic")
!!

<< python / test / zspawn
	#! <python3+>
	Z.expect_no_arguments ()
	Z.zspawn (":: true")
	Z.zspawn (":: false", _panic = False)
!!

<< python / test / zexec
	#! <python3+>
	Z.expect_no_arguments ()
	Z.zexec (":: true")
!!

<< python / test / spawn
	#! <python3+>
	Z.expect_no_arguments ()
	Z.spawn ("true")
	Z.spawn ("false", _panic = False)
!!

<< python / test / exec
	#! <python3+>
	Z.expect_no_arguments ()
	Z.exec ("true")
!!

<< python / test / redirects
	#! <python3+>
	Z.expect_no_arguments ()
	Z.log_cut ()
	Z.spawn ("true", _stdin = Z.fd_open_null (), _fd_close = True)
	Z.spawn ("true", _stdout = Z.fd_open_null (), _fd_close = True)
	Z.spawn ("true", _stderr = Z.fd_open_null (), _fd_close = True)
	Z.spawn ("true", _stdin = Z.fd_open_null (), _stdout = Z.fd_open_null (), _stderr = Z.fd_open_null (), _fd_close = True)
	Z.spawn ("cat", _stdin = Z.fd_open_for_read ("/etc/hosts"), _stdout = Z.fd_open_null (), _fd_close = True)
	Z.log_cut ()
	Z.spawn ("lsof", "-p", "%d" % Z.pid, _stdin = Z.fd_open_null (), _stderr = Z.fd_open_null (), _stdout = Z.fd_clone (Z.stderr), _fd_close = True)
	Z.log_cut ()
	Z.spawn ("lsof", "-c", "lsof", _stdin = Z.fd_open_null (), _stderr = Z.fd_open_null (), _stdout = Z.fd_clone (Z.stderr), _fd_close = True)
	Z.log_cut ()
	Z.spawn ("lsof", "-c", "lsof", _stdin = Z.fd_open_null (), _stderr = Z.fd_open_null (), _stdout = Z.fd_clone (Z.stderr), _fd_close = True)
	Z.log_cut ()
!!

<< python / test / pipeline
	#! <python3+>
	Z.expect_no_arguments ()
	Z.pipeline ([
			Z.cmd ("true"),
			Z.cmd ("sleep", "0.1s"),
			Z.cmd ("cat"),
			Z.cmd ("sleep", "0.2s"),
			Z.cmd ("true"),
		])
!!

<< python / test / wait
	#! <python3+>
	Z.expect_no_arguments ()
	_pid = Z.spawn ("true", _wait = False)
	assert 0 == Z.process_wait (_pid, _panic = False)
	_pid = Z.spawn ("false", _wait = False)
	assert 1 == Z.process_wait (_pid, _panic = False)
	_pid = Z.spawn ("sleep", "6s", _wait = False)
	Z.process_terminate (_pid, _wait = False)
	assert -Z.py.signal.SIGTERM == Z.process_wait (_pid, _panic = False)
	_pid = Z.spawn ("sleep", "6s", _wait = False)
	Z.process_kill (_pid, _wait = False)
	assert -Z.py.signal.SIGKILL == Z.process_wait (_pid, _panic = False)
!!

<< python / test / communicate
	#! <python3+>
	Z.expect_no_arguments ()
	_output = Z.spawn ("echo", "abc", _stdout_data = True)
	assert _output == "abc\n"
	_output = Z.spawn ("echo", "abc", _stdout_data = str)
	assert _output == "abc\n"
	_output = Z.spawn ("echo", "abc", _stdout_data = bytes)
	assert _output == b"abc\n"
	_output = Z.spawn ("cat", _stdin_data = "abc\n", _stdout_data = str)
	assert _output == "abc\n"
	_output = Z.spawn_capture ("echo", "abc")
	assert _output == "abc\n"
	_output = Z.spawn_capture ("echo", "{}", _json = True)
	assert _output == {}
!!

<< python / test / pipes
	#! <python3+>
	Z.expect_no_arguments ()
	_input, _output = Z.fd_open_pipes ()
	Z.fd_close (_input)
	Z.fd_close (_output)
!!

<< python / test / paths / join
	#! <python3+>
	Z.expect_no_arguments ()
	assert Z.path ("/etc") == "/etc", "[c86740bc]"
	assert Z.path ("//etc/.") == "/etc", "[1caa1de9]"
	assert Z.path (("/etc", "hosts")) == "/etc/hosts", "[b1c36167]"
	assert Z.path (("/etc/hosts", "/proc/self")) == "/proc/self", "[e126cddb]"
	assert Z.path ("/proc/self", _canonical = True) != "/proc/self", "[0909bbcb7]"
!!

<< python / test / paths / split
	#! <python3+>
	assert "/folder" == Z.path_dirname ("/folder/file")
	assert "/folder/file" == Z.path_dirname ("/folder/file/")
	assert "file" == Z.path_basename ("/folder/file")
	assert "" == Z.path_basename ("/folder/file/")
	assert "a/b/c" == Z.path_normalize ("./a/././/./x/../b/c//")
	assert "/" == Z.path_normalize ("/")
	assert "a" == Z.path_normalize ("a/")
	assert "/a" == Z.path_normalize ("/a")
	assert "/a" == Z.path_normalize ("/a/")
	assert None == Z.path_extension (".a")
	assert "a" == Z.path_extension ("x.a")
	assert "a" == Z.path_extension ("x.y.a")
	assert ".a" == Z.path_without_extension (".a")
	assert "x" == Z.path_without_extension ("x.a")
	assert "x.y" == Z.path_without_extension ("x.y.a")
	assert True == Z.path_matches ("/x/y/abc/cde/fgh", "*/a*c/*")
	assert True == Z.path_matches ("/x/y/abc/cde/fgh", "*/a*e/*")
	assert False == Z.path_matches ("/x/y/abc/cde/fgh", "a*e")
	assert "/folder" == Z.path_dirname (Z.path_temporary_for ("/folder/file.ext"))
	assert Z.environment.TMPDIR == Z.path_dirname (Z.path_temporary_in (None, "file.ext"))
!!

<< python / test / stat
	#! <python3+>
	Z.expect_no_arguments ()
	Z.exists ("/etc", _panic = 0x2ebc156a)
	Z.not_exists ("/__none__", _panic = 0x6412700c)
	Z.is_folder ("/etc", _panic = 0x6f67d170)
	Z.is_file ("/etc/hosts", _panic = 0xf67ac126)
	Z.is_file_or_folder ("/etc", _panic = 0xea1ecf05)
	Z.is_file_or_folder ("/etc/hosts", _panic = 0xbf9c1575)
	Z.is_symlink ("/proc/self", _panic = 0x492a6caf)
	Z.is_folder ("/proc/self", _panic = 0x6746e58d)
	Z.is_socket ("/dev/log", _panic = 0x708c3426)
	Z.is_dev_block ("/dev/sda", _panic = 0x7ac9ef0f)
	Z.is_dev_char ("/dev/null", _panic = 0xa8623aa9)
	Z.is_special ("/dev/sda", _panic = 0x8ea394a4)
	Z.is_special ("/dev/null", _panic = 0x3d458181)
	Z.is_special ("/dev/log", _panic = 0xb3b9fb84)
	Z.exists ("/dev/log", _panic = 0xc83ed2ae)
	Z.is_file_not_empty ("/etc/hosts", _panic = 0xec23876b)
	Z.is_file_empty ("/proc/self/environ", _panic = 0x80a8c78c)
!!

<< python / test / environment
	#! <python3+>
	Z.expect_no_arguments ()
	for _name in sorted (Z.environment.__iter__ ()) :
		print ("%s == %s" % (_name, Z.environment[_name]))
	print (Z.environment.PATH)
	print (Z.environment_or_none.NEW)
	Z.environment.PATH = "/dev/null/1"
	Z.environment.NEW = "/dev/null/2"
	print (os.environ["PATH"])
	print (os.environ["NEW"])
!!

<< python / test / sleep
	#! <python3+>
	Z.expect_no_arguments ()
	Z.sleep (0.1)
!!

<< python / test / touch
	#! <python3+>
	Z.expect_no_arguments ()
	Z.touch ("/tmp/z-run-python-tests--touch")
!!

<< python / test / files
	#! <python3+>
	Z.expect_no_arguments ()
	_token = Z.random_token (128)
	Z.file_write ("/tmp/z-run-python-tests--files", '{"a":"%s"}' % _token)
	_output = Z.file_read ("/tmp/z-run-python-tests--files")
	assert _output == '{"a":"%s"}' % _token
	_output = Z.file_read ("/tmp/z-run-python-tests--files", _json = True)
	assert _output == {"a":_token}
	_token = Z.random_token (128)
	Z.file_write ("/tmp/z-run-python-tests--files", {"a":_token}, _json = True)
	_output = Z.file_read ("/tmp/z-run-python-tests--files", _json = True)
	assert _output == {"a":_token}
!!

<< python / test / random
	#! <python3+>
	Z.expect_no_arguments ()
	assert isinstance (Z.random_bytes (0), Z.py.bytes)
	assert isinstance (Z.random_token (0), Z.py.str)
	assert isinstance (Z.random_integer (0), int)
	assert isinstance (Z.random_float (0, 1), float)
	assert isinstance (Z.random_range (0, 1), int)
	assert isinstance (Z.random_sample ([], 0), list)
	assert isinstance (Z.random_shuffle ([]), list)
	for _index in range (1000) :
		assert len (Z.random_bytes (4)) == 4
		assert len (Z.random_token (4)) == 4 * 2
		assert Z.random_token (2) >= "0000"
		assert Z.random_token (2) <= "ffff"
		assert Z.random_integer (8) >= 0
		assert Z.random_integer (8) <= 256
		assert Z.random_float (0, 1) >= 0
		assert Z.random_float (0, 1) <= 1
		assert Z.random_range (0, 256) >= 0
		assert Z.random_range (0, 256) <= 256
		assert Z.random_range (0, 256, 5) % 5 == 0
		assert Z.random_select ([0, 1, 2]) in [0, 1, 2]
		assert len (Z.random_sample ([0, 1, 2, 3], 2, _repeats = False)) == 2
		assert len (Z.random_sample ([0, 1, 2, 3], 8, _repeats = True)) == 8
		assert len (Z.random_shuffle ([0, 1, 2, 3])) == 4
!!

